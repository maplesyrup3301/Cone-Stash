# 信息表示
每一个计算机系统都有一个“字长”，表示计算机CPU在一个指令内能够处理的比特数，同时也是计算机虚拟内存空间的最大长度。例如，32位系统的虚拟内存地址就始于0x0000_0000，终于0xffff_ffff
C语言提供的一些类型及其占据空间的大小如下表：

| 有符号变种     | 无符号变种            | 字节数（32位） | 字节数（64位） |
| --------- | ---------------- | -------- | -------- |
| `char`    | `unsigned char`  | 1        | 1        |
| `short`   | `unsigned short` | 2        | 2        |
| `int`     | `unsigned int`   | 4        | 4        |
| `long`    | `unsigned long`  | 4        | 8        |
| `int32_t` | `uint32_t`       | 4        | 4        |
| `int64_t` | `uint64_t`       | 8        | 8        |
| `char*`   |                  | 4        | 8        |
| `float`   |                  | 4        | 4        |
| `double`  |                  | 8        | 8        |
可见其中`char*`的大小（虚拟内存空间地址的大小）与对应的字长一致
`int32_t`与`int64_t`等是C提供的定长类型，它们占据的空间不会像`long`一样在不同平台间改变

不同的系统可能采用不同的存储顺序：
1. 大端序（Big Endian）：MSB的地址在LSB之前
2. 小端序（Little Endian）：LSB的地址在MSB之前
Windows, Linux使用小端序，而Sun使用大端序
## C语言
### 按位逻辑运算
C语言提供按位逻辑运算符，它们对于给定的两个操作数，将其的二进制表示的每一位一一对应后作逻辑运算，产生出一串新的二进制数
```c
uint8_t a = 0b01101001;
uint8_t b = 0b10111011;
uint8_t a_not = ~a; // 0b10010110
uint8_t a_and_b = a & b; // 0b00101001
uint8_t a_or_b = a | b; // 0b11111011
uint8_t a_xor_b = a ^ b; // 0b11010010
```
### 一般逻辑运算
C语言提供一般逻辑运算符，它们将任何非零值都视为逻辑真，否则视为逻辑假，并且它们的输出只能是0或1，表示真或假
```c
uint8_t a = 0x00;
uint8_t b = 0x01;
uint8_t a_not = !a; // 0x01
uint8_t a_and_b = a && b; // 0x00
uint8_t a_or_b = a || b; // 0x01
```
### 移位运算
C语言提供左移位运算符`<<`，它抛弃原二进制表示的MSB并在低位补零
C语言也提供右移位运算符`>>`，但是它的定义是模糊的，因为右移位运算可以分为两种：
1. 逻辑移位：此时高位补零
2. 算术移位：此时高位补原MSB
在实际上，通常对有符号数采用算术移位，对无符号数采用逻辑移位
并且，在C中由于定义的关系，因此应该尽量保证位移量短于类型长度，因为尽管对于一个`int`来说，位移超过32位会被对32取模，理论上应该无影响，但是这一行为是不能够保证的，因此需要避免位移超过类型长度
## 字符串表示
## 整型表示
记一个数$x$的二进制表示为：
$$
X=[x]_2
$$
其中
1. $x$称为真数，所表示是数的概念，只是为了易读而采用10进制书写；
2. $X$称为真数$x$的二进制表示，二进制表示的统称记为$X_{(2)}$，上下文中可推知时可不写
3. $[]$代表的操作称为“表示”，右下角的“2”表明是二进制表示，未指明时可以不写
自然地，$x$的$n$进制表示记为$[x]_n$

已知数$x, y$，其表示为$X, Y$，则表示的运算与数的运算有关系：
$$
X+Y=[x+y]
$$
$X-Y, XY$也有此关系；其他进制表示的加减法计算方式与10进制一致，只是进位规则不同。这些运算没有位数限制，因此这些运算称为自由运算

给定一个模$k^w$同余类$\mathbb Z/\mathbb Zk^w$，其每个等价类中大于等于0的最小元素称为其主元素，则该同余类有一个独特的主元素集；将主元素集中所有的元素转化为其对应的$k$-表示，可以定义一个$k,w$-定长表示集$\mathscr E_k^w$，其所有元素的非零位最高不超过第$w$位，称为$k, w$-定长表示，每一个表示代表着一个等价类

例如：
$$
\mathscr E_2^3=\{000, 001, 010, 011, 100, 101, 110 ,111\}
$$
其中$000$代表着真数$0, 8, 16\dots$，也就是对应着$\mathbb Z/\mathbb Z8$中的等价类$\overline{0}$；

虽然此时表示不再是双射了，但是按模$n$等价类的运算，依然可以定义定长表示间的运算，这些运算的结果有位数限制，凡是超过位数限制的都截断了，符合现实需求，对应的运算也称为约束运算
$$
X^{(w)}+Y^{(w)}=[\o x+\o y]
$$
例如：
$$
\array{
101+110=[\overline 5+\overline 6]=[\overline3]=011\\
101-110=[\overline 5 - \overline 6]=[\overline 7]=111\\
101*110=[\overline 5\times \overline 6]=[\overline 6]=110
}
$$
在释读时，我们不认为$000$可以代表$8$，而是只取它的字面真数$0$，因此在$2,3$-定长表示集中，可能出现相加反而减小的现象（溢出），这是模运算（截断）的直接结果，也是计算机整型的一大性质

给定一个表示求真数的逆运算称为求值，记为$x=\v[X]$
给定一个$k,w$-定长表示$X^{(w)}$，显然它的字面真数为：
$$
\v[X^{(w)}]_2=\sum_{i=0}^{w-1}X_i2^i
$$
当$X_i^{(w)}=1(i=0,\dots, w-1)$，二进制表示对应的字面真数达到最大$UMax_w$
$$
UMax_w=2^w-1
$$
上述就是无符号整型的构造与运算；

为了构造有符号数，在$2,w$-定长表示集中，令$\neg X$为按位取反运算，我们可以注意到：
$$
\neg X^{(w)}+X^{(w)}=11\dots1^{(w)}=[\o {2^w-1}]
$$
则：
$$
\neg X^{(w)}+X^{(w)}+[\o 1]^{(w)}=[\o{2^w}]=[\o 0]
$$
因此，在定长表示集中：$\neg X^{(w)}+[\o 1]^{(w)}$是$X^{(w)}$的逆元，也就是说：
$$
X^{(w)}=[\o x]^{(w)}, \neg X^{(w)}+[\o 1]^{(w)}=[\o{-x}]^{(w)}
$$
$\neg X^{(w)}+[\o 1]^{(w)}$称为$X^{(w)}$的补码
选取最高位为符号位，若为1就将其作为补码释读，否则就将其按原码释读，这就是有符号数的释读法
例如当$w=4$时$1110+0110=0100$就可以释读为$6-2=4$
此时$TMax_w=2^{w-1}-1, TMin_w=2^{w-1}$
按有符号数释读，取值上界为$011\dots1$，取值下界为$100\dots0$
## 浮点数表示